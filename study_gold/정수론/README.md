# 1. 최대공약수(GCD)와 최소공배수(LCM)

> 유클리드 호제법: 주어진 두 수 사이에 존재하는 최대공약수(GCD)를 구하는 알고리즘

```python
def GCD(a, b):
    if b > a:			# a가 큰 수, b가 작은 수
        a, b = b, a
    while b != 0:		# a % b == 0일 때 b가 최대공약수이다
        a, b = b, a%b	# while문 안에서 b를 a에 대입했으므로 최종 return값은 a
    return a
```

- 최소공배수(LCM) = (a * b) //GCD



# 2. 소수

>  소수: 1과 자신 이외의 자연수로는 나눠떨어지지 않는 1보다 큰 자연수

- 에라토스테네스의 체

  1. 2부터 N까지 모두 소수(True)라는 리스트를 만든다

  2. 2부터 순서대로 확인하면서 소수이면 그 숫자의 배수들은 소수가 아님(False)으로 바꾼다

  3. N의 최대 약수는 `N**0.5`니까 int(`N**0.5`)보다 큰 수들은 체크할 필요가 없다

     → 이전에 더 작은 수의 배수로 체크가 되고 소수만 남아있음

```markdown
ex) n = 36이면 6까지 확인?
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36

2(배수 제외) / 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35

2 3(배수 제외) / 5 7 11 13 17 19 23 25 29 31 35

2 3 5(배수 제외) / 7 11 13 17 19 23 29 31
```

```python
def is_prime(n):
    prime = [1] * (n+1)
    prime[0] = prime[1] = 0
    # n의 최대 약수는 n**0.5 이하니까 2부터 n**0.5까지 체크
    m = int(n**0.5)
    for i in range(2, m+1):
        # i가 소수이면 i의 배수들은 소수가 아니니까 0으로 만들기
        if prime[i]:
            for j in range(2*i, n+1, i):
                prime[j] = 0
    return [k for k in range(2, n+1) if prime[k]]
```



# 3. 소인수분해

```python
N = int(input())
i = 2
ans = []
while i*i <= N:     # 여기가 핵심인듯? N이 a*b일때 둘 중 하나는 i보다 작거나 같다...?
    while N % i == 0:
        ans.append(i)
        N //= i
    i += 1
if N > 1:           # 마지막 남은 N이 소수인 경우
    ans.append(i)
```



